# 🎧 消息监听部署指南

## 🎯 三种监听方案对比

| 方案 | 实时性 | 资源消耗 | 可靠性 | 推荐度 |
|------|--------|---------|--------|--------|
| **WebSocket** | ⭐⭐⭐⭐⭐ | 低 | 中 | ⭐⭐⭐ |
| **轮询监听** | ⭐⭐⭐ | 中 | 高 | ⭐⭐⭐⭐⭐ |
| **智能监听** | ⭐⭐⭐⭐ | 低 | 高 | ⭐⭐⭐⭐⭐ |

---

## 方案1：WebSocket监听（最实时）

### 优点
- ✅ 实时推送（延迟<1秒）
- ✅ 资源消耗低
- ✅ 服务器压力小

### 缺点
- ⚠️ 需要网站支持WebSocket
- ⚠️ 连接可能断开需要重连
- ⚠️ 可能不稳定

### 使用方法
```bash
node websocket-listener.js
```

### 适用场景
- 网站支持WebSocket
- 需要极低延迟
- 消息非常频繁

---

## 方案2：轮询监听（最可靠）⭐⭐⭐⭐⭐

### 优点
- ✅ 非常可靠
- ✅ 实现简单
- ✅ 不依赖特殊协议
- ✅ 易于调试

### 缺点
- ⚠️ 有延迟（取决于检查间隔）
- ⚠️ 会产生定期请求

### 使用方法
```bash
# 默认60秒检查一次
node polling-listener.js

# 自定义间隔（30秒）
node polling-listener.js 30

# 高频检查（10秒）
node polling-listener.js 10
```

### 推荐配置
```bash
# 日常使用：60秒
node polling-listener.js 60

# 活跃时段：30秒
node polling-listener.js 30

# 重要活动：10秒
node polling-listener.js 10
```

### 适用场景
- 大多数情况（推荐）
- 需要稳定可靠
- 消息不是特别频繁

---

## 方案3：智能监听（最智能）⭐⭐⭐⭐⭐

### 优点
- ✅ 自动调整检查频率
- ✅ 资源消耗最优
- ✅ 根据活跃度智能调整
- ✅ 特殊时段优化

### 特性
- 📈 **高活跃**（5+条/小时）→ 30秒检查一次
- 📊 **中活跃**（2-4条/小时）→ 60秒检查一次
- 📉 **低活跃**（1条/小时）→ 120秒检查一次
- 💤 **无活跃**（0条/小时）→ 300秒检查一次
- 🌙 **凌晨时段**（0-6点）→ 降低频率
- 🌆 **晚间时段**（18-23点）→ 提高频率

### 使用方法
```bash
node smart-listener.js
```

### 适用场景
- 长期运行（推荐）
- 需要节省资源
- 消息频率不固定

---

## 🚀 服务器部署

### 方案A：使用PM2（推荐）

#### 安装PM2
```bash
npm install -g pm2
```

#### 启动监听器
```bash
# 智能监听（推荐）
pm2 start smart-listener.js --name "msg-listener"

# 或轮询监听
pm2 start polling-listener.js --name "msg-listener" -- 60

# 查看状态
pm2 status

# 查看日志
pm2 logs msg-listener

# 停止
pm2 stop msg-listener

# 重启
pm2 restart msg-listener
```

#### 开机自启
```bash
# 保存当前PM2配置
pm2 save

# 生成启动脚本
pm2 startup

# 按照提示执行命令
```

#### PM2配置文件
创建 `ecosystem.config.js`:
```javascript
module.exports = {
  apps: [{
    name: 'msg-listener',
    script: './smart-listener.js',
    cwd: '/path/to/auto-login-test',
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '500M',
    env: {
      NODE_ENV: 'production'
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss'
  }]
};
```

启动：
```bash
pm2 start ecosystem.config.js
```

---

### 方案B：使用systemd

创建服务文件 `/etc/systemd/system/msg-listener.service`:
```ini
[Unit]
Description=Message Listener Service
After=network.target

[Service]
Type=simple
User=your_user
WorkingDirectory=/path/to/auto-login-test
ExecStart=/usr/bin/node smart-listener.js
Restart=always
RestartSec=10
StandardOutput=append:/var/log/msg-listener.log
StandardError=append:/var/log/msg-listener-error.log

[Install]
WantedBy=multi-user.target
```

启动服务：
```bash
# 重新加载systemd
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start msg-listener

# 开机自启
sudo systemctl enable msg-listener

# 查看状态
sudo systemctl status msg-listener

# 查看日志
sudo journalctl -u msg-listener -f
```

---

### 方案C：使用Docker

创建 `Dockerfile`:
```dockerfile
FROM node:20-alpine

WORKDIR /app

# 安装依赖
COPY package*.json ./
RUN npm ci --only=production

# 复制代码
COPY . .

# 安装Patchright浏览器
RUN npx patchright install chromium

CMD ["node", "smart-listener.js"]
```

创建 `docker-compose.yml`:
```yaml
version: '3.8'

services:
  msg-listener:
    build: .
    container_name: msg-listener
    restart: unless-stopped
    env_file:
      - .env
    volumes:
      - ./logs:/app/logs
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

运行：
```bash
# 构建并启动
docker-compose up -d

# 查看日志
docker-compose logs -f

# 停止
docker-compose down
```

---

## 📊 监控和维护

### 查看运行状态

#### PM2
```bash
pm2 status
pm2 monit
pm2 logs msg-listener --lines 100
```

#### systemd
```bash
sudo systemctl status msg-listener
sudo journalctl -u msg-listener -n 100
```

#### Docker
```bash
docker ps
docker logs msg-listener -f
```

### 性能监控

创建监控脚本 `monitor.sh`:
```bash
#!/bin/bash

while true; do
  echo "=== $(date) ==="
  
  # CPU和内存使用
  ps aux | grep "smart-listener.js" | grep -v grep
  
  # 网络连接
  netstat -an | grep ESTABLISHED | grep -c "message.hinatazaka46.com"
  
  echo ""
  sleep 60
done
```

---

## 🔧 故障处理

### Token过期
监听器会自动检测Token过期并尝试刷新：
```javascript
// 自动刷新Token
if (error.response?.status === 401) {
  await this.refreshToken();
}
```

### 连接失败
- 检查网络连接
- 检查Token是否有效
- 查看错误日志

### 内存泄漏
```bash
# 设置内存限制
pm2 start smart-listener.js --max-memory-restart 500M
```

---

## 💡 最佳实践

### 1. 选择合适的方案
- **开发测试**：轮询监听（60秒）
- **生产环境**：智能监听
- **高频场景**：WebSocket（如果支持）

### 2. 配置合理的间隔
```
高频：10-30秒（活动期间）
中频：60秒（日常使用）
低频：300秒（深夜时段）
```

### 3. 设置监控告警
```bash
# 监听器停止时发送通知
if ! pm2 list | grep -q "msg-listener.*online"; then
  curl -X POST $DISCORD_WEBHOOK \
    -d '{"content": "⚠️ 监听器已停止！"}'
fi
```

### 4. 定期检查日志
```bash
# 每天检查一次
0 9 * * * tail -100 /var/log/msg-listener.log | mail -s "监听器日志" your@email.com
```

### 5. 备份配置
```bash
# 备份.env和配置文件
tar -czf backup-$(date +%Y%m%d).tar.gz .env *.js
```

---

## 🎯 推荐配置

### 个人使用
```bash
# 智能监听 + PM2
pm2 start smart-listener.js --name "msg-listener"
pm2 save
pm2 startup
```

### 服务器部署
```bash
# Docker + 智能监听
docker-compose up -d

# 或 systemd + 智能监听
sudo systemctl enable msg-listener
sudo systemctl start msg-listener
```

---

## 📝 总结

**最推荐的方案**：
1. **智能监听** + **PM2** + **自己的服务器**
2. 自动调整检查频率
3. 稳定可靠
4. 资源消耗低
5. 易于维护

**运行命令**：
```bash
cd /path/to/auto-login-test
pm2 start smart-listener.js --name "msg-listener"
pm2 save
pm2 startup
```

完成！🎉
